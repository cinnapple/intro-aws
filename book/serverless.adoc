== Serverless architecture

Serverless Architecture あるいは Serverless Computing とは， 従来とは全くアプローチの異なるクラウドシステムの設計方法である．
歴史的には， AWS が2014年に発表した https://aws.amazon.com/lambda/[Lamba] がサーバーレスアーキテクチャの最初の先駆けとされている．
その後， Google や Microsoft などのクラウドプラットフォームも同様の機能の提供を開始している．
サーバーレスアーキテクチャの利点は，スケーラブルなクラウドシステムを安価かつ簡易に作成できる点であり，近年いたるところで導入が進んでいる．

Serverless とは，文字通りの意味としてはサーバーなしで計算をするということになるが，それは一体どういう意味だろうか？
サーバーレスについて説明するためには，まずは従来的な， "serverful" と呼ばれるようなシステムについて解説しなければならない．

=== Serverful クラウド (従来型)

従来的なクラウドシステムのスケッチを <<serverful>> に示す．
クライアントから送信されたリクエストは，まず最初にAPIサーバーに送られる．
API サーバーでは，リクエストの内容に応じてタスクが実行される．
タスクには，APIサーバーだけで完結できるものもあるが，多くの場合，データベースの読み書きが必要である．
データベースには，データベース専用の独立したサーバーマシンが用いられることが一般的である．
また，画像や動画などもデータは，また別のストレージサーバーに保存されることが一般的である．
これらの APIサーバー，データベースサーバー，ストレージサーバーはそれぞれ独立したサーバーマシンであり， AWS では EC2 を使った仮想インスタンスを想定してもらったら良い．

多くのウェブサービスでは，多数のクライアントからのリクエストを処理するため，複数のサーバーマシンがクラウド内で起動し，負荷を分散するような設計がなされている．
クライアントから来たリクエストを計算容量に余裕のあるサーバーに振り分けるような操作を **Load balancing** とよび，そのような操作を担当するマシンのことを **Load balancer** という． 

Load balancing の目的でたくさんのインスタンスを起動するのはよいのだが，それぞれがなんの計算もせず，ただ新しいタスクが来るのを待っているようではコストと電力の無駄遣いである．
したがって，全てのサーバーが常に目標とする計算負荷を維持するよう，計算の負荷に応じてクラスター内の仮想サーバーの数を動的に増減させるような仕組みが必要である．
そのような仕組みを**クラスターのスケーリング**とよび，負荷の増大に応答して新しい仮想インスタンスをクラスターに追加する操作を **scale-in**，負荷の減少に応答してインスタンスをシャットダウンする操作を **scale-out** と呼ぶ．
クラスターのスケーリングは，各インスタンスを監視・統括するようなひとつ階層が上のサーバーを配置することで自動的に実行されるような設計がなされる．
クラスターのスケーリングは， API サーバーではもちろんのこと，データベースサーバー・ストレージサーバーでも必要になることが多い．
**クラウドシステム内すべてのインスタンスで，負荷が均一になるような調整が必要なのである．**

[[serverful]]
.Serverful なクラウドシステム
image::imgs/serverful.png[serverful, 700, align="center"]

=== Serverless クラウドへ

上述したように，従来のクラウドシステムの設計で非常に重要なのが，クラスターのスケーリングである．
コストパフォーマンスを最大化するには，各サーバーの稼働率を100%に近づけるようなスケーリングのパラメータの調整が必要である．
しかしながら，クラスターのスケーリングの最適化はかなり手間のかかる作業である．

さらに問題を複雑にするのは，APIサーバーで処理されるべきタスクが，非一様である点である．
非一様であるとは，例えばタスクAは3000ミリ秒の実行時間と 512MB のメモリーを消費し，別のタスクBは1000ミリ秒の実行時間と 128MB のメモリーを消費する，というような状況を差している．
一つのサーバーマシンが計算負荷が異なる複数のタスクを処理する場合，クラスターのスケーリングはより複雑になる．
この状況をシンプルにするために，１サーバーで実行するタスクは１種類に限る，という設計も可能であるが，そうするとで生まれる弊害も多い (ほとんど使われないタスクに対してもサーバー一台をまるまる割り当てなければならない = ほとんどアイドリング状態になってしまう，など)．

もっとシンプルで見通しの良いクラウドシステムのスケーリングの仕組みはないだろうか？

従来の serverful なシステムでの最大の問題点は，**サーバーをまるまる占有してしまう**という点にある．
すなわち， EC2 インスタンスを起動したとき，そのインスタンスは起動したユーザーだけが使えるものであり，**計算のリソース (CPUやRAM) が独占的に割り当てられた状態**になる．
固定した計算資源の割り当てがされてしまっているので，**インスタンスの計算負荷が0%であろうが100%であろうが，均一の使用料金が起動時間に比例**して発生する．

サーバーレスアーキテクチャは，このような **独占的に割り当てられた計算リソースというものを完全に廃止する．**
サーバーレスアーキテクチャでは，計算のリソースは，クラウドプロバイダーが全て管理する．
クライアントは実行したいプログラムをクラウドに提出する．
クラウドプロバイダーは，自身の持つ巨大な計算リソースから空きを探し，提出されたプログラムを実行し，実行結果をクライアントに返す．
以上を図示すると， <<serverless>> のようになる．

[[serverless]]
.従来のクラウドと Serverless クラウドの比較
image::imgs/serverless.png[serverless, 700, align="center"]

サーバーレスクラウドを利用することで，**クラウドのコストは実際に使用した計算の総量 (CPU稼働時間) で決定される**ことになる．
これは，計算の実行総量に関わらずインスタンスの起動時間で料金が決定されていた従来のシステムと比べて大きな違いである．

これまで，抽象的な説明が続いてきたが，以下では AWS のサーバーレスクラウドに実際に触れてみることで，より具体的な例を見ていこう．

=== Lambda

image:imgs/aws_logos/Lambda.png[Lambda, 100]

https://aws.amazon.com/lambda/[Lambda] はAWSのサーバーレスクラウドの最も根幹をなす機能である．

Lambda の使い方は以下の3ステップである．

. 実行するコード (Python や node.js など) を Lambda にアップロードする．
. 実行に使用するメモリー容量と最大実行時間を指定
. 上記で定義した関数を実行するリクエストを Lambda に送信

Lambda はサーバーレスな計算サービスなので，仮想インスタンスを専有することはない．
AWS は，上のようにして定義された関数を， AWS の持つ巨大な計算リソースの中から空きを見つけて，実行する．
同時に複数のリクエストが来た場合でも， AWS はそれらを実行するための計算リソースを割り当て，並列的に処理を行ってくれる．
原理上は，**数千から数万のリクエストが同時に来たとしても， Lambda はそれらを同時に実行することができる**．
このような，サーバーレスで関数を実行するサービスは **FaaS (Function as a Service)** と呼ばれる．

Lambda では 128MB から 3008MB のメモリーを使用することができる (2020/06時点)．
実行時間は100ミリ秒の単位で記録され，実行時間に比例して料金が決定される．
<<lambda_pricing>> は Lambda の利用料金の利用料金表である．

[[lambda_pricing]]
[cols="1,1", options="header"] 
.Lambda の料金表
|===
|Memory (MB)
|Price per 100ms

|128
|$0.0000002083

|512
|$0.0000008333

|1024
|$0.0000016667

|3008
|$0.0000048958
|===

例えば， 128MB のメモリーを使用する関数を，それぞれ200ミリ秒，合計で100万回実行した場合，
0.0000002083 * 2 * 10^6 = **$0.4** の料金となる．
ウェブサーバーのデータベースの更新など簡単な計算であれば，200ミリ秒程度で実行できる関数も多いことから，100万回データベースの更新を行ったとしても，たった $0.4 しかコストが発生しないことになる．

=== Lambda ハンズオン

ここでは，ショートハンズオンとして，実際に AWS 上に Lambda を使った関数を定義し，計算を実行してみよう．
ここでは， AWS CDK を利用してとてもシンプルな Lambda の関数を作成する．

ハンズオンのソースコードは https://gitlab.com/tomomano/intro-aws/-/tree/master/handson/04-serverless/lambda[こちらのリンク] に置いてある．

[WARNING]
====
このハンズオンは，基本的に https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&all-free-tier.sort-order=asc[AWS Lambda の無料枠] の範囲内で実行することができる．
====

https://gitlab.com/tomomano/intro-aws/-/tree/master/handson/04-serverless/lambda/app.py[app.py] にデプロイするプログラムが書かれている．
中身を見てみよう．

[source, python]
----
# <1>
FUNC = """
import time
from random import choice, randint
def handler(event, context):
    time.sleep(randint(2,5))
    pokemon = ["Charmander", "Bulbasaur", "Squirtle"]
    message = "Congratulations! You are given " + choice(pokemon)
    print(message)
    return message
"""

class SimpleLambda(core.Stack):

    def __init__(self, scope: core.App, name: str, **kwargs) -> None:
        super().__init__(scope, name, **kwargs)

        # <2>
        handler = _lambda.Function(
            self, 'LambdaHandler',
            runtime=_lambda.Runtime.PYTHON_3_7,
            code=_lambda.Code.from_inline(FUNC),
            handler="index.handler",
            memory_size=128,
            timeout=core.Duration.seconds(10),
            dead_letter_queue_enabled=True,
        )
----
<1> ここで， Lambda で実行されるべき関数を定義している．
これは非常に単純な関数で，2-5秒のランダムな時間スリープした後，["Charmander", "Bulbasaur", "Squirtle"] のいずれかの文字列をランダムに返す (これらは初代ポケットモンスターのゲームでオーキド博士にもらうヒトカゲ・フシギダネ・ゼニガメのことだ)・
<2> 次に， Lambda の関数の諸々のパラメータを設定している．
それぞれのパラメータの意味は，文字通りの意味なので明瞭であるが，以下に解説する．
* `runtime=_lambda.Runtime.PYTHON_3_7`:
ここでは， Python3.7 を使って上記で定義された関数を実行せよ，と指定している． 
Python3.7 の他に， node.js, Java, Ruby, Go などの言語を指定することが可能である．
* `code=_lambda.Code.from_inline(FUNC)`:
実行されるべき関数が書かれたコードを指定する．
ここでは， `FUNC=...` で定義した文字列を渡しているが，文字列以外にもファイルのパスを渡すことも可能である．
* `handler="index.handler"`:
これは，コードの中にいくつかのサブ関数が含まれているときに，メインとサブを区別するためのパラメータである．
`handler` という名前の関数をメイン関数として実行せよ，という意味である．
* `memory_size=128`:
メモリーは 128MB を最大で使用することを指定している．
メモリーオーバーした場合は
* `timeout=core.Duration.seconds(10)`
タイムアウト時間を10秒に設定している．
10秒以内に関数の実行が終了しなかった場合，エラーが返される．
* `dead_letter_queue_enabled=True`:
アドバンストな設定なので説明は省略する．

上記のプログラムを実行することで， Lambda 関数がクラウド上に作成される．
早速デプロイしてみよう．

==== デプロイ

デプロイの手順は，これまでのハンズオンとほとんど共通である．
ここでは，コマンドのみ列挙する (`#` で始まる行はコメントである)．
それぞれの意味を忘れてしまった場合は，ハンズオン1, 2に戻って復習していただきたい．

[source, bash]
----
# プロジェクトのディレクトリに移動
$ cd intro-aws/handson/04-serverless/lambda

# venv を作成し，依存ライブラリのインストールを行う
$ python3 -m venv .env
$ source .env/bin/activate
$ pip install -r requirements.txt

# AWS の認証情報をセットする
# 自分自身の認証情報に置き換えること！
export AWS_ACCESS_KEY_ID=XXXXXX
export AWS_SECRET_ACCESS_KEY=YYYYYY
export AWS_DEFAULT_REGION=ap-northeast-1

# デプロイを実行
$ cdk deploy
----

デプロイのコマンドが無事に実行されれば， <<handson_04_lambda_cdk_output>> のような出力が得られるはずである．
ここで表示されている `SimpleLambda.FunctionName = XXXX` の XXX の文字列は後で使うのでメモしておこう．

[[handson_04_lambda_cdk_output]]
.CDKデプロイ実行後の出力
image::imgs/handson-04/handson_04_lambda_cdk_output.png[cdk output, 700, align="center"]

AWS コンソールにログインして，デプロイされたスタックを確認してみよう．
コンソールから，Lambda のページに行くと <<handson_04_lambda_console_func_list>> のような画面から Lambda の関数の一覧が確認できる．

[[handson_04_lambda_console_func_list]]
.Lambda コンソール - 関数の一覧
image::imgs/handson-04/lambda_console_func_list.png[cdk output, 700, align="center"]

今回のアプリケーションで作成したのが `SimpleLambda-XXXX` という名前のついた関数だ．
関数の名前をクリックして，詳細を見てみる．
すると <<handson_04_lambda_console_func_detail>> のような画面が表示されるはずだ．
先ほどプログラムの中で定義したPythonの関数がエディターから確認することができる．
また，下の方にスクロールすると，関数の各種設定も確認することができる．

[[handson_04_lambda_console_func_detail]]
.Lambda コンソール - 関数の詳細
image::imgs/handson-04/lambda_console_func_detail.png[lambda_console_func_detail, 700, align="center"]

==== Lambda 関数の実行

それでは，作成した Lambda 関数を実際に実行 (invoke) してみよう．
AWS の API を使うことで，関数の実行をスタートすることができる．
今回は， https://gitlab.com/tomomano/intro-aws/-/tree/master/handson/04-serverless/lambda/invoke_one.py[invoke_one.py] に関数を実行するための簡単なプログラムを提供している．
興味のある読者はコードを読んでもらいたい．

以下のコマンドで，Lambda の関数を実行する．
コマンドの `XXXX` の部分はは，先ほどデプロイしたときに `SimpleLambda.FunctionName = XXXX` で得られた XXXX の文字列で置換する．

[source, bash]
----
$ python invoke_one.py XXXX
----

すると， `"Congratulations! You are given Squirtle"` という出力が得られるはずだ．
とてもシンプルではあるが，クラウド上で先ほどの関数が走り，乱数が生成された上で，ポケモンが選択されて出力が返されている．
上のコマンドを何度か打ってみて，実行のごとに違うポケモンが返されることを確認しよう．

さて，上のコマンドは，一度につき一回の関数を実行したわけであるが， Lambda の本領は一度に大量のタスクを同時に実行できる点である．
そこで，今度は一度に100個のタスクを同時に送信してみよう．

以下のコマンドを実行する．
XXXX の部分は上と同様に置き換える．
第二引数の `100` は 100個のタスクを投入せよ，という意味である．

[source, bash]
----
$ python invoke_many.py XXXX 100
----

すると以下のような出力が得られるはずだ．

[source, bash]
----
....................................................................................................
Submitted 100 tasks to Lambda!
----

実際に，100 個のタスクが同時に実行されていることを確認しよう．
<<handson_04_lambda_console_func_detail>> の画面に戻り， "Monitoring" というタブがあるので，それをクリックする．
すると， <<handson_04_lambda_console_monitoring>> のようなグラフが表示されるだろう．

[[handson_04_lambda_console_monitoring]]
.Lambda コンソール - 関数の実行のモニタリング
image::imgs/handson-04/lambda_console_monitoring.png[lambda_console_monitoring, 700, align="center"]

[WARNING]
====
<<handson_04_lambda_console_monitoring>> のグラフの更新には数分かかることがあるので，なにも表示されない場合は少し待つ．
====

<<handson_04_lambda_console_monitoring>> で "Invocations" が関数が何度実行されたかを意味している．
たしかに100回実行されていることがわかる．
さらに， "Concurrent executions" が何個のタスクが同時に行われたかを示している．
ここでは 96 となっていることから，96個のタスクが並列的に実行されたことを意味している．
(これが，100とならないのは，タスクの開始のコマンドが送られたのが完全には同タイミングではないことに起因する)

このように，非常にシンプルではあるが， Lambda を使うことで，同時並列的に処理を実行することのできるクラウドシステムを簡単に作ることができた．

もしこのようなことを従来的な serverful なクラウドで行おうとした場合，クラスターのスケーリングなど多くのコードを書くことに加えて，いろいろなパラメータを調節する必要がある．

[TIP]
====
興味がある人は，一気に1000個などのジョブを投入してみると良い．
が，あまりやるすぎると Lambda の無料利用枠を超えて料金が発生してしまうので注意．
====

==== スタックの削除

最後にスタックを削除しよう．

スタックを削除するには，次のコマンドを実行すればよい．

[source, bash]
----
$ cdk destroy
----

